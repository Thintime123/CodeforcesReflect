本篇提供 LCA 算法的介绍、倍增（二分提升）实现流程，以及个人的类模板。

---

## 1. 什么是 LCA？

- **定义**：在一棵以某个节点（通常是 1）为根的树中，给定两个节点 u, v，它们的 **最近公共祖先（Lowest Common Ancestor, LCA）** 是同时是 u 和 v 的祖先中，距离它们最近的那个节点。

---

## 2. 为什么要用二分提升？

- **暴力做法**：每次查询 u, v 时，挨个往上跑，一个节点一个节点地向上找，会导致最坏 O(N) 时间，N≈树高。多次查询时太慢。
    
- **二分提升思想**：先预处理，让每个节点都记录“2^k 级祖先”（k=0,1,2…），这样查询时可以一次性“跳”大步向上，时间 O(log N)。
    

---

## 3. 算法流程

1. **建树并跑一遍 DFS（或 BFS）**
    
    - 记录每个节点的深度 `depth[x]`
        
    - 记录每个节点的直接父节点 `fa[0][x]`
        
2. **预处理 $fa[k][i]$**
    
    - 对所有 k 从 1 到 $⌊log₂N⌋$，对所有节点 i：
        
        ```
        fa[k][i] = fa[k-1][ fa[k-1][i] ]
        ```
        
    - 含义：$fa[k][i]$ 是 i 的 2^k 级祖先。
        
3. **查询 LCA(u,v)**
    
    - **第一步**：让 u, v 深度对齐。若 $depth[u]$ > $depth[v]$，就把 u 往上跳 `depth[u]-depth[v]` 层；反之同理。
        
    - **第二步**：如果 u == v，直接返回；否则从大 k 开始往下尝试，让 u 和 v 同时朝它们的 2^k 级祖先跳，如果跳完后两者依然不相同，就继续往下 k-1 跳……
        
    - 最后跳不到更高才结束，此时 `fa[0][u]` 就是答案。
        

---

## 4. 复杂度

- **预处理**：DFS O(N)，构造 fa 表 O(N log N)。
    
- **单次查询**：对齐深度 O(log N) + 搜索祖先 O(log N)，合计 O(log N)。
    

---

## 5. 算法模板（C++）

```cpp
class LCA {
private:
	int n;
	int LOG;
	vector<vector<int>> adjlist;
	vector<int> depth;
	vector<vector<int>> fa;

	void dfs(int u, int p) {
		fa[0][u] = p;
		depth[u] = p ? depth[p] + 1 : 0;

		for(int v : adjlist[u]) {
			if(v != p) {
				dfs(v, u);
			}
		}
	}

	void init_lca(int root) {
		dfs(root, 0);
		fer(k, 1, LOG) {
			fer(i, 1, n + 1) {
				int mid = fa[k - 1][i];
				fa[k][i] = mid ? fa[k - 1][mid] : 0;
			}
		}
	}

public:
	// 节点从 1 开始编号
	LCA(const vector<vector<int>>& tree, int root)
		: n(tree.size() - 1),
		  LOG(__lg(n) + 1),
		  adjlist(tree),
		  depth(n + 1, 0),
		  fa(LOG + 1, vector<int>(n + 1))
	{
		init_lca(root);
	}

	int query(int u, int v) {
		if(depth[u] < depth[v]) swap(u, v);
		int diff = depth[u] - depth[v];

		// 深度对齐
		fer(k, 0, LOG) {
			if(diff & (1 << k)) {
				u = fa[k][u];
			}
		}
		if(u == v) return u;

		ferd(k, LOG, 0) {
			if(fa[k][u] && fa[k][u] != fa[k][v]) {
				u = fa[k][u];
				v = fa[k][v];
			}
		}
		return fa[0][u];
	}
};
```

- **实现说明**
	- `dfs` ： 处理直接父亲，处理节点的深度
	- `init_lca(root)` ： 初始化操作，进行上面的 `dfs`，并且初始化 `fa` 表（处理节点 $i$ 的 $2^k$ 级祖先）
	- `query(u, v)` ： 查询两个节点的 LCA

- **使用说明**
	-  n 是节点数
	- 节点编号默认从 1 开始
	- 根节点深度默认为 0

---

## 6. 拓展

了解「$Euler Tour + RMQ」$方法，可实现 O(1) 查询，但预处理更复杂。


