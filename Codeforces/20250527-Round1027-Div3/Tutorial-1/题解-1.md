## [题目链接](https://codeforces.com/contest/2114)

## A. Square Year

### 思路
1. 考虑到年份是四位数，所以在[1, 100]范围内枚举$a$和$b$即可
2. 也可以直接判断年份是否为完全平方数

### 示例代码

```cpp
void solve() {  
   int n;  
   cin >> n;  
  
   fer(a, 0, 100) {  
       fer(b, 0, 100) {  
           if(pow(a + b, 2) == n) {  
               cout << a << ' ' << b << '\n';  
               return;  
           }  
       }  
   }  
   cout << -1 << '\n';  
}
```
```cpp
void solve() {  
   int n;  
   cin >> n;  
      
   if(floor(sqrt(n)) * floor(sqrt(n)) == n) {  
       cout << 0 << ' ' << int(sqrt(n)) << '\n';  
       return;  
   }  
   cout << -1 << '\n';  
}
```


## B. Not Quite a Palindromic String

### 思路

题意是说将二进制串任意排列后使得恰好有$k$对匹配。我们可以先统计$0$和$1$的个数，将多出来的先匹配，然后依次同时使$00$匹配和$11$匹配，也就是必须两对两对匹配，所以只需要判断现在$k$的奇偶性即可。
### 示例代码
```cpp
void solve() {  
   int n, k;  
   cin >> n >> k;  
   string s;  
   cin >> s;  
  
   int cnt0 = 0, cnt1 = 0;  
   for(char c : s) {  
       if(c == '0') cnt0++;  
       else cnt1++;  
   }  
  
   k -= abs(cnt0 - cnt1) / 2;  
   cnt0 = cnt1 = min(cnt0, cnt1);  
  
   cout << (k & 1 ? "NO" : "YES") << '\n';  
}
```

## C. Need More Arrays

### 思路

题意是将非降序数组中数值相等或相邻的数放入同一个数组中，操作是我们可以删除若干个元素，使得最终得到的数组个数最大化。那么可以贪心，如果后续的数$b$与最新可用的数$a$相邻，则把这个数$b$删除，最后统计即可。

### 示例代码

```cpp
  
void solve() {  
   int n;  
   cin >> n;  
   vector<int> arr(n);  
  
   fer(i, 0, n) cin >> arr[i];  
  
   vector<bool> vis(n + 1, true);  
  
   int ind = 0;  
   fer(i, 1, n) {  
       if(arr[i] <= arr[ind] + 1 && vis[ind]) {  
           vis[i] = false;  
       } else ind = i;  
   }  
   int cnt = 1;  
   fer(i, 1, n) {  
       if(!vis[i - 1] && vis[i]) {  
           cnt++;  
       } else {  
           if(vis[i] && vis[i - 1] && arr[i] > arr[i - 1] + 1) cnt++;  
       }  
   }  
   cout << cnt << '\n';  
}
```

## D. Come a Little Closer

### 思路

题意是指我们可以移动一个方格（怪物），使得框住所有怪物的矩形面积最小化。
可以查找边界点，分别讨论移动独立的边界点之后面积的变化，最后取$min$即可，要注意的是：有可能在移动边界上的怪物时，其余怪物已经成一个矩形的情况。

示例代码

```cpp
void solve() {  
   int n;  
   cin >> n;  
   vector<pii> px(n), py(n);  
  
   fer(i, 0, n) {  
       cin >> px[i].first >> py[i].first;  
       px[i].second = i;  
       py[i].second = i;  
   }  
   sort(all(px)), sort(all(py));  
  
   if(n == 1) {  
       cout << 1 << '\n';  
       return;  
   }  
  
   ll ans = 1LL * (px[n - 1].first - px[0].first + 1) * (py[n - 1].first - py[0].first + 1);  
   int cxmin = 1, cxmax = 1, cymin = 1, cymax = 1;  
   int xmin = px[0].first, xmax = px[n - 1].first, ymin = py[0].first, ymax = py[n - 1].first;  
  
   fer(i, 1, n) {  
       if(px[i].first == px[0].first) cxmin++;  
       else break;  
   }  
   ferd(i, n - 2, 0) {  
       if(px[i].first == px[n - 1].first) cxmax++;  
       else break;  
   }  
   fer(i, 1, n) {  
       if(py[i].first == py[0].first) cymin++;  
       else break;  
   }  
   ferd(i, n - 2, 0) {  
       if(py[i].first == py[n - 1].first) cymax++;  
       else break;  
   }  
   if(cxmin == 1) {  
       xmin = px[1].first;  
       xmax = px[n - 1].first;  
       ymin = py[0].first;  
       ymax = py[n - 1].first;  
       for(auto& [y, ind] : py) {  
           if(ind != px[0].second) {  
               ymin = y;  
               break;  
           }  
       }  
       for(int i = n - 1; i >= 0; --i) {  
           auto [y, ind] = py[i];  
           if(ind != px[0].second) {  
               ymax = y;  
               break;  
           }  
       }  
       ll res = 1LL * (xmax - xmin + 1) * (ymax - ymin + 1);  
       if(res == n - 1) res += min(xmax - xmin + 1, ymax - ymin + 1);  
       ans = min(ans, res);  
   }  
   if(cxmax == 1) {  
       xmin = px[0].first;  
       xmax = px[n - 2].first;  
       ymin = py[0].first;  
       ymax = py[n - 1].first;  
       for(auto& [y, ind] : py) {  
           if(ind != px[n - 1].second) {  
               ymin = y;  
               break;  
           }  
       }  
       for(int i = n - 1; i >= 0; --i) {  
           auto [y, ind] = py[i];  
           if(ind != px[n - 1].second) {  
               ymax = y;  
               break;  
           }  
       }  
       ll res = 1LL * (xmax - xmin + 1) * (ymax - ymin + 1);  
       if(res == n - 1) res += min(xmax - xmin + 1, ymax - ymin + 1);  
       ans = min(ans, res);  
   }  
   if(cymin == 1) {  
       xmin = px[0].first;  
       xmax = px[n - 1].first;  
       ymin = py[1].first;  
       ymax = py[n - 1].first;  
       for(auto& [x, ind] : px) {  
           if(ind != py[0].second) {  
               xmin = x;  
               break;  
           }  
       }  
       for(int i = n - 1; i >= 0; --i) {  
           auto [x, ind] = px[i];  
           if(ind != py[0].second) {  
               xmax = x;  
               break;  
           }  
       }  
       ll res = 1LL * (xmax - xmin + 1) * (ymax - ymin + 1);  
       if(res == n - 1) res += min(xmax - xmin + 1, ymax - ymin + 1);  
       ans = min(ans, res);  
   }  
   if(cymax == 1) {  
       xmin = px[0].first;  
       xmax = px[n - 1].first;  
       ymin = py[0].first;  
       ymax = py[n - 2].first;  
       for(auto& [x, ind] : px) {  
           if(ind != py[n - 1].second) {  
               xmin = x;  
               break;  
           }  
       }  
       for(int i = n - 1; i >= 0; --i) {  
           auto [x, ind] = px[i];  
           if(ind != py[n - 1].second) {  
               xmax = x;  
               break;  
           }  
       }  
       ll res = 1LL * (xmax - xmin + 1) * (ymax - ymin + 1);  
       if(res == n - 1) res += min(xmax - xmin + 1, ymax - ymin + 1);  
       ans = min(ans, res);  
   }  
   cout << ans << '\n';  
}
```

## E. Kirei Attacks the Estate

### 思路

$dfs + dp$ ，自身节点对后一个节点产生与自身相反的影响，所以我们需要用两个$dp$数组记录本节点的正影响和负影响。

### 示例代码

```cpp
void dfs(int u, vector<vector<int>>& adjlist, vector<ll>& w, vector<bool>& vis, vector<ll>& dpmin, vector<ll>& dpmax) {  
   for(int v : adjlist[u]) {  
       if(!vis[v]) {  
           vis[v] = true;  
           dpmax[v] = max(dpmax[v], w[v] - dpmin[u]);  
           dpmin[v] = min(dpmin[v], w[v] - dpmax[u]);  
           dfs(v, adjlist, w, vis, dpmin, dpmax);  
       }  
   }  
}  
  
void solve() {  
   int n;  
   cin >> n;  
   vector<vector<int>> adjlist(n + 1);  
   vector<ll> w(n + 1);  
  
   fer(i, 1, n + 1) cin >> w[i];  
   fer(i, 0, n - 1) {  
       int u, v;  
       cin >> u >> v;  
       adjlist[u].push_back(v);  
       adjlist[v].push_back(u);  
   }  
   vector<bool> vis(n + 1, false);  
   vector<ll> dpmin(n + 1, 0), dpmax(n + 1, 0);  
   fer(i, 1, n + 1) {  
       dpmin[i] = dpmax[i] = w[i];  
   }  
  
   vis[1] = true;  
   dfs(1, adjlist, w, vis, dpmin, dpmax);  
   fer(i, 1, n + 1) cout << dpmax[i] << ' ';

	cout << '\n';
}
```

